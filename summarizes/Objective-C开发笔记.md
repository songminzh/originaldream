[TOC]

# Objective-C开发笔记

## 1. 面向过程和面向对象

### 面向过程

1. 把完成某一个需求的所有步骤从头到尾逐步实现
2. 根据开发需求，将某些功能独立的代码封装成一个又一个的函数
3. 最后完成的代码，就是顺序地调用不同的函数

特点

1. 注重步骤与过程，不注重职责分工
2. 如果需求复杂，代码会变得更复杂
3. 开发复杂项目，没有固定的套路，开发难度很大

### 面向对象

1. 在完成某一个需求前，需要确定职责--要做的事情（方法）
2. 根据职责确定不同的对象，在对象内部封装不同的方法（多个）
3. 最后完成的代码，就是顺序地让不同的对象调用不同的方法

特点

1. 注重对象和职责，不同的对象承担不同的职责
2. 更加适合应对复杂的需求变化，是专门应当复杂项目开发，提供的固定套路。

### 区别

相比较面向过程，面向对象注重更大的封装，根据职责对一个对象重封装多个方法。

面向对象的优点是易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统；

面向过程的优点是性能高。

## 2. 编译过程

### 概念

编译（compilation）：把高级语言变成计算机可以识别的2进制语言的过程。

1Swift --> Objective-C --> C --> 汇编 --> 机器语言

### 编译器

前端(Frontend)：Clang，前端负责语法分析、词法分析，生成中间代码

后端(Backend)：LLVM，后端以中间代码作为输入，进行架构无关的代码优化，接着针对不同架构生成不同的机器码

### 过程

- 预处理：Clang会预处理你的代码，比如把宏嵌入到对应的位置、注释被删除，条件编译被处理
- 词法分析：词法分析器读入源文件的字符流，将他们组织称有意义的词素(lexeme)序列，对于每个词素，此法分析器产生词法单元（token）作为输出。并且会用Loc来记录位置。
- 语法分析：这一步是把词法分析生成的标记流，解析成一个抽象语法树（abstract syntax tree -- AST）,同样地，在这里面每一节点也都标记了其在源码中的位置。
  AST 是抽象语法树，结构上比代码更精简，遍历起来更快，所以使用 AST 能够更快速地进行静态检查。
- 静态分析：把源码转化为抽象语法树之后，编译器就可以对这个树进行静态分析处理。静态分析会对代码进行错误检查，如出现方法被调用但是未定义、定义但是未使用的变量等，以此提高代码质量。当然，还可以通过使用 Xcode 自带的静态分析工具（Product -> Analyze)进行手动分析。最后 AST 会生成 IR，IR 是一种更接近机器码的语言，区别在于和平台无关，通过 IR 可以生成多份适合不同平台的机器码。
  静态分析的阶段会进行类型检查，比如给属性设置一个与其自身类型不相符的对象，编译器会给出一个可能使用不正确的警告。在此阶段也会检查时候有未使用过的变量等。
- 中间代码生成和优化：此阶段LLVM 会对代码进行编译优化，例如针对全局变量优化、循环优化、尾递归优化等，最后输出汇编代码xx.ll文件。
  生成汇编代码： 汇编器LLVM会将汇编码转为机器码。此时的代码就是.o文件，即二进制文件。
- 链接：连接器把编译产生的.o文件和（dylib,a,tbd）文件，生成一个mach-o文件。mach-o文件级可执行文件。编译过程全部结束，生成了可执行文件Mach-O

## 3.类方法和实例方法

### 概述

#### 实例方法（动态方法）

标识符：- 开头

调用方式：[实例对象 方法]

实例方法在堆栈上

#### 类方法（静态方法）

标识符：+ 开头

调用方式：[类 方法]

类方法在堆上分配内存

#### 使用准则

1. 如果需要访问或者修改某个实例的成员变量时，将该方法定义成实例方法。
2. 类方法正好相反，它不需要访问或者修改某个实例的成员变量。
3. 类方法一般用于实现一些工具方法，比如对某个对象进行扩展，或者实现单例。

## 4.自动引用计数

### ARC基本原理

ARC是Automatic Reference Counting(自动引用计数器)的简称。

ARC的规则就是只要对象没有强指针引用，就会被释放掉。换而言之，只要还有一个强引用指针变量指向对象，那么这个对象就会存在内存中。弱指针指向的对象，会被自动变成空指针（nil指针），从而不会引发野指针错误。

ARC是**编译器特性**，而不是运行时特性，更不是垃圾回收器(GC)，核心就是编译时插入相应的retian release。

- **strong 修饰符**：对象的默认修饰符，强引用表示，变量在超出作用域时会调用release方法。
- **weak 修饰符**：弱引用的表示，不持有对象实例；弱引用在对象被释放的时候，会自动重置为nil；
- **unsafe_unretained 修饰符**：弱引用的表示，不持有对象实例；对象在被释放的时候，不会重置为nil；当对象释放后，再调用有极大的可能性崩溃；
- **autoreleasing 修饰符**：将NSObject 类对象注册到autoreleasepool 中；

生成并持有对象：alloc、new、copy、mutableCopy 
持有对象：retain方法 
释放对象：release方法 
废弃对象：dealloc方法 

### 总结

1. 在OC的对象中存有引用计数器这一整数值；
2. 调用alloc或者retain方法后，引用计数器加1；
3. 调用release后，引用计数器减1；
4. 当引用计数器值为0时，调用dealloc方法销毁对象。

